---
title: "BAL"
output: html_document
---

The data is from BAL Extraction 5-29-19. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


First, the packages must be loaded.
```{r warning= FALSE}
library(openCyto)
library(flowClust)
library(data.table)
library(flowCore)
library(ggcyto)
library(FlowSOM)
library(dplyr)
library(pheatmap)
library(stringr)
library(tidyr)
library(readxl)
library(gridExtra)
library(ggcorrplot)
library(tidyverse)
library(scales)
library(viridis)
library(kableExtra)
```

I have created a few functions to make it easier to analyze the data.

- `clean_sc_after_gate`: renames the columns; it also removes SSC boundary effects
- `.findpeaks`: copied from <https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R> to use in later mindensity function [Amy, I think it would be better practice for us to refer to this function, if it's in the current version of its package, within the function where we want to use it, rather than copying the definition here. That method would work better as we move toward making some of the code a package. We can discuss if that would make sense and how to do it, if so.]
- `.findvalleys`: copied from <https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R> to use in later mindensity function
- `gate_mindensity_amy`: this is a function that I adapted from <https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R> the difference between the original mindensity function and mine is that the original only works with a flowframe, while mine performs the same function on a dataframe. Mine also prints out the cutpoint so we can see it.
- `statSmoothFunc`: copied from <https://gist.github.com/kdauria/524eade46135f6348140> to add $r^2$ to correlation plots [See my comment from "BCG_Survival.Rmd"]
- `stat_smooth_func`: copied from <https://gist.github.com/kdauria/524eade46135f6348140> to add $r^2$ to correlation plots
- `phenotype_heatmap`: to create the phenotype graphs with the populations and marker expression [Amy, if we have functions we want to use in several of these documents, we should create a more general R script to define those functions and then "source" it at the start of each Rmd. That way, if you want to change something in one of the functions, you won't have to worry about making sure you do it in all the Rmds.]
- `as.numeric.factor`: convert the factors for the marker names into numeric for plotting [See my comment from "BCG_Survival.Rmd"]

```{r}

clean_after_gate <- function(fcs_file) {
  fcs_file %>%
  select(ends_with(".A"), -`FSC.A`, `SSC.A`, filename) %>%
  dplyr::rename(`CD4` = "BV421.A",
                 `CD11B` = "Pacific.Blue.A",
                 `MHCII` = "BV480.A",
                `CD45` = "BV570.A",
                 `CD19` = "BV605.A",
                 `CCR2` = "BV711.A",
                 `NK1.1` = "BV785.A",
                 `CD8` = "FITC.A",
                 `CD11C` = "Alexa.Fluor.532.A",
                 `CD326` = "PE.A",
                 `CD3` = "PE.Dazzle594.A",
                 `Ly6G` = "PerCP.A",
                 `CD41` = "PE.Cy7.A",
                 `Ter119` =  "APC.A",
                 `Ly6C` = "Alexa.Fluor.700.A",
                 `Live` = "Zombie.NIR.A",
                 `GD_TCR` = "APC.Fire.750.A")  %>%
   na.omit()%>%
  dplyr::filter(`SSC.A` != max(`SSC.A`))

}

# this function is from OpenCyto Github RGLab https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R
.find_peaks <- function(x, y = NULL, num_peaks = NULL, adjust = 2, plot = FALSE, ...) {
  x <- as.vector(x)

  if (length(x) < 2) {
    warning("At least 2 observations must be given in 'x' to find peaks.")
    return(NA)
  }

  if (is.null(y)) {
    dens <- density(x, adjust = adjust, ...)
  } else {
    y <- as.vector(y)
    if (length(x) != length(y)) {
      stop("The lengths of 'x' and 'y' must be equal.")
    }
    dens <- list(x = x, y = y)
  }

  # Discrete analogue to a second derivative applied to the KDE. See details.
  second_deriv <- diff(sign(diff(dens$y)))
  which_maxima <- which(second_deriv == -2) + 1

  # The 'density' function can consider observations outside the observed range.
  # In rare cases, this can actually yield peaks outside this range.  We remove
  # any such peaks.
  which_maxima <- which_maxima[findInterval(dens$x[which_maxima], range(x)) == 1]

  # Next, we sort the peaks in descending order based on the density heights.
  which_maxima <- which_maxima[order(dens$y[which_maxima], decreasing = TRUE)]
  
  # Returns the local maxima. If there are none, we return 'NA' instead.
  if (length(which_maxima) > 0) {
    peaks <- dens$x[which_maxima]
    if (is.null(num_peaks) || num_peaks > length(peaks)) {
      num_peaks <- length(peaks)
    }
    peaks <- peaks[seq_len(num_peaks)]
  } else {
    peaks <- NA
  }
  
  peaks <- data.frame(x = peaks, y = dens$y[which_maxima][seq_len(num_peaks)])
  if(plot){
    plot(dens, main = paste("adjust =" ,  adjust))
    points(peaks, ,col = "red")  
  }
  
  peaks  
}

# this function is from OpenCyto Github RGLab https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R
.find_valleys <- function(x, y = NULL, num_valleys = NULL, adjust = 2, ...) {

  x <- as.vector(x)

  if (length(x) < 2) {
    warning("At least 2 observations must be given in 'x' to find valleys.")
    return(NA)
  }
  
  if (is.null(y)) {
    dens <- density(x, adjust = adjust, ...)
  } else {
    y <- as.vector(y)
    if (length(x) != length(y)) {
      stop("The lengths of 'x' and 'y' must be equal.")
    }
    dens <- list(x = x, y = y)
  }

  # Discrete analogue to a second derivative applied to the KDE. See details.
  second_deriv <- diff(sign(diff(dens$y)))
  which_minima <- which(second_deriv == 2) + 1

  # The 'density' function can consider observations outside the observed range.
  # In rare cases, this can actually yield valleys outside this range. We remove
  # any such valleys.
  which_minima <- which_minima[findInterval(dens$x[which_minima], range(x)) == 1]

  # Next, we sort the valleys in descending order based on the density heights.
  which_minima <- which_minima[order(dens$y[which_minima], decreasing = FALSE)]

  # Returns the local minima. If there are none, we return 'NA' instead.
  if (length(which_minima) > 0) {
    valleys <- dens$x[which_minima]
    if (is.null(num_valleys) || num_valleys > length(valleys)) {
      num_valleys <- length(valleys)
    }
    valleys <- valleys[seq_len(num_valleys)]
  } else {
    valleys <- NA
  }
  valleys
}


gate_mindensity_amy <- function(df, channel, filterId = "", positive = TRUE,
                       pivot = FALSE, gate_range = NULL, min = NULL, max = NULL,
                       peaks = NULL, ...) {
  
  if (missing(channel) || length(channel) != 1) {
    stop("A single channel must be specified.")
  }

  # Filter out values less than the minimum and above the maximum, if they are
  # given.

  # I altered this to take in a dataframe rather than fcs file
  x <- df[, channel]
  
  if(is.null(peaks))
    peaks <- .find_peaks(x)[, "x"]
  
  if (is.null(gate_range)) {
    gate_range <- c(min(x), max(x))
  } else {
    gate_range <- sort(gate_range)
  }

  
  
  # In the special case that there is only one peak, we are conservative and set
  # the cutpoint as min(x) if 'positive' is TRUE, and max(x) otherwise.
  if (length(peaks) == 1) {
    cutpoint <- ifelse(positive, gate_range[1], gate_range[2])
  } else {
    # The cutpoint is the deepest valley between the two peaks selected. In the
    # case that there are no valleys (i.e., if 'x_between' has an insufficient
    # number of observations), we are conservative and set the cutpoint as the
    # minimum value if 'positive' is TRUE, and the maximum value otherwise.
    valleys <- try(.find_valleys(x), silent = TRUE)
    valleys <- .between_interval(x = valleys, interval = gate_range)

    if (any(is.na(valleys))) {
    #FIXME:currently it is still returning the first peak,
    #we want to pass density instead of x_between to 'min'
    #because x_between is the signal values
      cutpoint <- ifelse(positive, gate_range[1], gate_range[2])
    } else if (length(valleys) == 1) {
      cutpoint <- as.vector(valleys)
    } else if (length(valleys) > 1) {
      # If there are multiple valleys, we determine the deepest valley between
      # the two largest peaks.
      peaks <- sort(peaks[1:2])
      cutpoint <- .between_interval(valleys, peaks)[1]

      # If none of the valleys detected are between the two largest peaks, we
      # select the deepest valley.
      if (is.na(cutpoint)) {
        cutpoint <- valleys[1]
      }      
    }
  }
  gate_coordinates <- ifelse(positive, list(c(cutpoint, Inf)), list(c(-Inf, cutpoint)))
  
  names(gate_coordinates) <- channel
  
  rectangleGate(gate_coordinates, filterId = filterId)
  
  # I added in the print(cutpoint)
  print(cutpoint)
  
}

# taken from https://gist.github.com/kdauria/524eade46135f6348140
stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

viridis_colors <- c("#3F4788FF", "#56C667FF")


phenotype_heatmap <- function(csv_file, population_no, title) {
  pheatmap(csv_file, cluster_rows = FALSE, cluster_cols = FALSE, color = viridis_colors,
           labels_row = paste("Pop", population_no), main = title)
}

# need to convert the factors in the extracted_pheno to numeric for plotting
as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
```

The single color (sc) samples are read in and initially gated on singlets and leukocytes (there is no live/dead dye in this panel).

The samples are gated on singlets, live, Ter119- (RBCs), and CD45+ (Leukoctyes).

Note: The last gate (Leukocytes) should be ~8% positive rather than 2.5%

```{r}

# read in the gating strategy
ws <- list.files("../Data/flow/Andres_BAL_Exp", pattern = ".csv", full = TRUE)

# only for viewing that read in 
dtTemplate <- fread(ws) 

initial_gate <- gatingTemplate(ws) 

# read in the single color data
fcsFiles <- list.files("../Data/flow/Andres_BAL_Exp", 
                       pattern = ".fcs", full = TRUE)


# ncdfFlowset object contains row names with the individual samples and column names with the markers/parameters used in the flow cytometer
ncfs <- read.ncdfFlowSet(fcsFiles) 

# apply gating set
gs <- GatingSet(ncfs)

# gate the samples
gating(initial_gate, gs)

# View the gates
plotGate(gs[[1]], strip.text = "gate")

# Pull out the gated data
gated_data <- getData(gs, "live") %>% 
  as.flowSet() 

```

I then performed a logicle transformation. This is so that we can see the feature engineered cutoffs on a plot.

- normally FSC and SSC stay linear while the markers are logicle transformed

```{r fig.width = 9, fig.height=5, warning=FALSE}

#initialize dataframe where all data will go
gated_df_test = data.frame()

# convert each of the FMO files to a data frame, adding on the filename
# bind all of the FMO files into one dataframe
for (i in 1:length(gated_data)) {
    gated_data_redo <- gated_data[[i]] %>%
    exprs() %>%
    data.frame() %>%
    mutate(filename = sampleNames(gated_data[i])) 

  gated_df_test <- rbind(gated_df_test, gated_data_redo)
}

# confirm that all of the files were read in 
unique(gated_df_test$filename)

gated_df_test <- gated_df_test %>%
  clean_after_gate()
```


```{r}




ggplot(gated_df_test, aes(x = CD326, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD326")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD3, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD3")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD4, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD4")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD8, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD8")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = NK1.1, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "NK1.1")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = GD_TCR, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "GD_TCR")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD19, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  xlim(-10000, 200000) +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD19")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD41, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD41")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD11B, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD11B")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CD11C, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CD11C")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = Ly6C, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "Ly6C")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = Ly6G, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "Ly6G")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = MHCII, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "MHCII")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

ggplot(gated_df_test, aes(x = CCR2, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
   ylab("SSC-A") +
  xlim(-10000, 200000) +
   geom_vline(xintercept = gate_mindensity_amy(gated_df_test, "CCR2")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))
```


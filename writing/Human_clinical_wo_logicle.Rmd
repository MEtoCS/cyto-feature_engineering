---
title: "Human_clinical_wo_logical"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First, the packages must be loaded.
```{r warning= FALSE}
library(openCyto)
library(flowClust)
library(data.table)
library(flowCore)
library(ggcyto)
library(FlowSOM)
library(dplyr)
library(pheatmap)
library(stringr)
library(tidyr)
library(readxl)
library(gridExtra)
library(ggcorrplot)
library(tidyverse)
library(scales)
library(viridis)
library(kableExtra)
library(ggpubr)
```

I have created a few functions to make it easier to analyze the data.

- clean_sc_after_gate:renames the columns; it also removes SSC boundary effects
- .findpeaks: copied from <https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R> to use in later mindensity function
- .findvalleys: copied from <https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R> to use in later mindensity function
- gate_mindensity_amy: this is a function that I adapted from <https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R> the difference between the original mindensity function and mine is that the original only works with a flowframe, while mine performs the same function on a dataframe. Mine also prints out the cutpoint so we can see it.
- statSmoothFunc: copied from <https://gist.github.com/kdauria/524eade46135f6348140> to add r^2 to correlation plots
- stat_smooth_func: copied from <https://gist.github.com/kdauria/524eade46135f6348140> to add r^2 to correlation plots
- phenotype_heatmap: to create the phenotype graphs with the populations and marker expression
- as.numeric.factor: convert the factors for the marker names into numeric for plotting
```{r}

clean_sc_after_gate <- function(fcs_file) {
  fcs_file %>%
  select(ends_with(".A"), -`FSC.A`, `SSC.A`, filename) %>%
  dplyr::rename(`HLA_DR` = "FITC.A",
         `CD19` = "PE.A",
        `CD3` =  "PE.Cy5.A",       
         `CD45` = "PE.Cy7.A",
         `CD27` = "APC.A")  %>%
   na.omit()%>%
  dplyr::filter(`SSC.A` != max(`SSC.A`))

}

# this function is from OpenCyto Github RGLab https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R
.find_peaks <- function(x, y = NULL, num_peaks = NULL, adjust = 2, plot = FALSE, ...) {
  x <- as.vector(x)

  if (length(x) < 2) {
    warning("At least 2 observations must be given in 'x' to find peaks.")
    return(NA)
  }

  if (is.null(y)) {
    dens <- density(x, adjust = adjust, ...)
  } else {
    y <- as.vector(y)
    if (length(x) != length(y)) {
      stop("The lengths of 'x' and 'y' must be equal.")
    }
    dens <- list(x = x, y = y)
  }

  # Discrete analogue to a second derivative applied to the KDE. See details.
  second_deriv <- diff(sign(diff(dens$y)))
  which_maxima <- which(second_deriv == -2) + 1

  # The 'density' function can consider observations outside the observed range.
  # In rare cases, this can actually yield peaks outside this range.  We remove
  # any such peaks.
  which_maxima <- which_maxima[findInterval(dens$x[which_maxima], range(x)) == 1]

  # Next, we sort the peaks in descending order based on the density heights.
  which_maxima <- which_maxima[order(dens$y[which_maxima], decreasing = TRUE)]
  
  # Returns the local maxima. If there are none, we return 'NA' instead.
  if (length(which_maxima) > 0) {
    peaks <- dens$x[which_maxima]
    if (is.null(num_peaks) || num_peaks > length(peaks)) {
      num_peaks <- length(peaks)
    }
    peaks <- peaks[seq_len(num_peaks)]
  } else {
    peaks <- NA
  }
  
  peaks <- data.frame(x = peaks, y = dens$y[which_maxima][seq_len(num_peaks)])
  if(plot){
    plot(dens, main = paste("adjust =" ,  adjust))
    points(peaks, ,col = "red")  
  }
  
  peaks  
}

# this function is from OpenCyto Github RGLab https://github.com/RGLab/openCyto/blob/0ec1218427627b9ee092f8d39e6ab46d46e7e2f8/R/bayes-flowClust.R
.find_valleys <- function(x, y = NULL, num_valleys = NULL, adjust = 2, ...) {

  x <- as.vector(x)

  if (length(x) < 2) {
    warning("At least 2 observations must be given in 'x' to find valleys.")
    return(NA)
  }
  
  if (is.null(y)) {
    dens <- density(x, adjust = adjust, ...)
  } else {
    y <- as.vector(y)
    if (length(x) != length(y)) {
      stop("The lengths of 'x' and 'y' must be equal.")
    }
    dens <- list(x = x, y = y)
  }

  # Discrete analogue to a second derivative applied to the KDE. See details.
  second_deriv <- diff(sign(diff(dens$y)))
  which_minima <- which(second_deriv == 2) + 1

  # The 'density' function can consider observations outside the observed range.
  # In rare cases, this can actually yield valleys outside this range. We remove
  # any such valleys.
  which_minima <- which_minima[findInterval(dens$x[which_minima], range(x)) == 1]

  # Next, we sort the valleys in descending order based on the density heights.
  which_minima <- which_minima[order(dens$y[which_minima], decreasing = FALSE)]

  # Returns the local minima. If there are none, we return 'NA' instead.
  if (length(which_minima) > 0) {
    valleys <- dens$x[which_minima]
    if (is.null(num_valleys) || num_valleys > length(valleys)) {
      num_valleys <- length(valleys)
    }
    valleys <- valleys[seq_len(num_valleys)]
  } else {
    valleys <- NA
  }
  valleys
}


gate_mindensity_amy <- function(df, channel, filterId = "", positive = TRUE,
                       pivot = FALSE, gate_range = NULL, min = NULL, max = NULL,
                       peaks = NULL, ...) {
  
  if (missing(channel) || length(channel) != 1) {
    stop("A single channel must be specified.")
  }

  # Filter out values less than the minimum and above the maximum, if they are
  # given.

  # I altered this to take in a dataframe rather than fcs file
  x <- df[, channel]
  
  if(is.null(peaks))
    peaks <- .find_peaks(x)[, "x"]
  
  if (is.null(gate_range)) {
    gate_range <- c(min(x), max(x))
  } else {
    gate_range <- sort(gate_range)
  }

  
  
  # In the special case that there is only one peak, we are conservative and set
  # the cutpoint as min(x) if 'positive' is TRUE, and max(x) otherwise.
  if (length(peaks) == 1) {
    cutpoint <- ifelse(positive, gate_range[1], gate_range[2])
  } else {
    # The cutpoint is the deepest valley between the two peaks selected. In the
    # case that there are no valleys (i.e., if 'x_between' has an insufficient
    # number of observations), we are conservative and set the cutpoint as the
    # minimum value if 'positive' is TRUE, and the maximum value otherwise.
    valleys <- try(.find_valleys(x), silent = TRUE)
    valleys <- .between_interval(x = valleys, interval = gate_range)

    if (any(is.na(valleys))) {
    #FIXME:currently it is still returning the first peak,
    #we want to pass density instead of x_between to 'min'
    #because x_between is the signal values
      cutpoint <- ifelse(positive, gate_range[1], gate_range[2])
    } else if (length(valleys) == 1) {
      cutpoint <- as.vector(valleys)
    } else if (length(valleys) > 1) {
      # If there are multiple valleys, we determine the deepest valley between
      # the two largest peaks.
      peaks <- sort(peaks[1:2])
      cutpoint <- .between_interval(valleys, peaks)[1]

      # If none of the valleys detected are between the two largest peaks, we
      # select the deepest valley.
      if (is.na(cutpoint)) {
        cutpoint <- valleys[1]
      }      
    }
  }
  gate_coordinates <- ifelse(positive, list(c(cutpoint, Inf)), list(c(-Inf, cutpoint)))
  
  names(gate_coordinates) <- channel
  
  rectangleGate(gate_coordinates, filterId = filterId)
  
  # I added in the print(cutpoint)
  print(cutpoint)
  
}

# taken from https://gist.github.com/kdauria/524eade46135f6348140
stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

viridis_colors <- c("#3F4788FF", "#56C667FF")


phenotype_heatmap <- function(csv_file, population_no, title) {
  pheatmap(csv_file, cluster_rows = FALSE, cluster_cols = FALSE, color = viridis_colors,
           labels_row = paste("Pop", population_no), main = title)
}

# need to convert the factors in the extracted_pheno to numeric for plotting
as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
```

The single color (sc) samples are read in and initially gated on singlets and leukocytes (there is no live/dead dye in this panel).
```{r}

# read in the gating strategy
ws <- list.files("../Data/flow/Human_Clinical", pattern = "human_clinical_gating.csv", full = TRUE)

# only for viewing that read in 
dtTemplate <- fread(ws, autostart = 1L) 

initial_gate <- gatingTemplate(ws, autostart = 1L) 

# read in the single color data
sc_fcsFiles <- list.files("../Data/flow/Human_Clinical/Single_Colors", 
                       pattern = ".fcs", full = TRUE)


# ncdfFlowset object contains row names with the individual samples and column names with the markers/parameters used in the flow cytometer
ncfs_sc <- read.ncdfFlowSet(sc_fcsFiles) 

# apply gating set
gs_sc <- GatingSet(ncfs_sc)

# gate the samples
gating(initial_gate, gs_sc)

# View the gates
plotGate(gs_sc[[1]])

# Pull out the gated data
sc_gated_data <- getData(gs_sc, "leukocytes") %>% 
  as.flowSet() 

```

I then performed a logicle transformation. This is so that we can see the feature engineered cutoffs on a plot.

- normally FSC and SSC stay linear while the markers are logicle transformed

```{r fig.width = 9, fig.height=5, warning=FALSE}

#initialize dataframe where all data will go
sc_gated_df_test = data.frame()

# logicle transform of data in the listed channels 
# convert each of the FMO files to a data frame, adding on the filename
# bind all of the FMO files into one dataframe
for (i in 1:length(sc_gated_data)) {
  
  sc_data_test <- sc_gated_data[[i]] %>%
    exprs() %>%
    data.frame() %>%
    mutate(filename = sampleNames(sc_gated_data[i])) 

  sc_gated_df_test <- rbind(sc_gated_df_test, sc_data_test)
}

# confirm that all of the files were read in 
unique(sc_gated_df_test$filename)


```

Pull out single colors
```{r}

CD3_sc <- sc_gated_df_test %>%
  clean_sc_after_gate() %>%
  dplyr::filter(filename == "Specimen_001_cd3_004.fcs")

CD19_sc <- sc_gated_df_test %>%
  clean_sc_after_gate() %>%
  dplyr::filter(filename == "Specimen_001_cd19_003.fcs")

CD27_sc <- sc_gated_df_test %>%
  clean_sc_after_gate() %>%
  dplyr::filter(filename == "Specimen_001_cd27_006.fcs")

CD45_sc <- sc_gated_df_test %>%
  clean_sc_after_gate() %>%
  dplyr::filter(filename == "Specimen_001_cd45_005.fcs")

HLA_DR_sc <- sc_gated_df_test %>%
  clean_sc_after_gate() %>%
  dplyr::filter(filename == "Specimen_001_hla-dr_002.fcs")


```

Feature engineering single colors and plot

I will use OpenCyto to find the minimum density between the two peaks (positive and negative) to develop a cutoff. 
```{r fig.width = 9, fig.height=5, warning=FALSE}

p1 <-  ggplot(HLA_DR_sc, aes(x = HLA_DR, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(HLA_DR_sc, "HLA_DR")) +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

p2 <- ggplot(CD19_sc, aes(x = CD19, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(CD19_sc, "CD19"))+
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

p3 <- ggplot(CD3_sc, aes(x = CD3, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(CD3_sc, "CD3"))+
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

p4 <- ggplot(CD45_sc, aes(x = CD45, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(CD45_sc, "CD45"))+
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

p5 <- ggplot(CD27_sc, aes(x = CD27, y = SSC.A)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(CD27_sc, "CD27"))+
  scale_x_log10() +
  scale_y_log10() +
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

grid.arrange(p1, p2, p3, p4, p5, 
             nrow = 2)


ggplot(CD3_sc, aes(x = CD3)) +
   geom_histogram(bins =1000) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("SSC-A") +
   geom_vline(xintercept = gate_mindensity_amy(CD3_sc, "CD3"), color = "red")+
  theme_gray()+
  theme(axis.text = element_text(size =12),
        axis.title = element_text(size = 20))

```

Initial gating of sample data
```{r}
fcsFile <- list.files("../Data/flow/Human_Clinical/", 
                       pattern = ".fcs", full = TRUE)

# ncdfFlowset object contains row names with the individual samples and column names with the markers/parameters used in the flow cytometer
ncfs <- read.ncdfFlowSet(fcsFile) 

# apply gating set
gs <- GatingSet(ncfs)

# gate the samples
gating(initial_gate, gs)

# View the gates
plotGate(gs[[1]])

# Pull out the data
gated_data <- getData(gs, "leukocytes") %>% 
  as.flowSet() 

# initialize the gated data df
all_gated_df = data.frame()

# logicle transform of data in the listed channels 
# convert each of the FMO files to a data frame, adding on the filename
# bind all of the FMO files into one dataframe (though there is only 1 file)
for (i in 1:length(gated_data)) {
  
   gated_data_test <- gated_data[[i]]%>%
    exprs() %>%
    data.frame() %>%
    mutate(filename = sampleNames(gated_data[i])) 

  all_gated_df <- rbind(all_gated_df, gated_data_test)
}


```

Feature cut the data to get all of the possible populations for each file with the cell count and number of cells. Feature engineering is based on the minimum density between the single color peaks.

```{r}

all_gated <- all_gated_df %>%
  mutate(filename= str_replace_all(filename, "\\s", "_")) %>%
  select(ends_with(".A"), -`FSC.A`, filename) %>%
  dplyr::rename(`HLA_DR` = "FITC.A",
         `CD19` = "PE.A",
        `CD3` =  "PE.Cy5.A",       
         `CD45` = "PE.Cy7.A",
         `CD27` = "APC.A")  %>%
  na.omit() %>%
  dplyr::filter(`SSC.A` != max(`SSC.A`)) %>%
  mutate(HLA_DR = cut(HLA_DR, breaks = c(min(HLA_DR), gate_mindensity_amy(HLA_DR_sc, "HLA_DR"), max(HLA_DR)), 
                       labels = c("0", "1")),
         CD19 = cut(CD19, breaks = c(min(CD19), gate_mindensity_amy(CD19_sc, "CD19"), max(CD19)),
                       labels = c(0, 1)),
         CD3 = cut(CD3, breaks = c(min(CD3), gate_mindensity_amy(CD3_sc, "CD3"), max(CD3)),
                       labels = c(0, 1)),
         CD45 = cut(CD45, breaks = c(min(CD45), gate_mindensity_amy(CD45_sc, "CD45"),  max(CD45)), 
                    labels = c(0, 1)),
         CD27 = cut(CD27, breaks = c(min(CD27), gate_mindensity_amy(CD27_sc, "CD27"), max(CD27)), 
                    labels = c(0, 1))) %>%
  mutate_at(vars(-group_cols()), funs(tidyr::replace_na(.,0))) %>%
  select(-`SSC.A`) %>%
  group_by(HLA_DR, CD19, CD3, CD45, CD27, filename) %>%
  dplyr::mutate(cell_no = n()) %>%
  unique() %>%
  ungroup() %>%
  dplyr::group_by(filename) %>%
  dplyr::mutate(total_count_by_file = sum(cell_no),
         percentage = (100*cell_no / total_count_by_file)) %>%
  mutate_if(is.factor, ~as.numeric.factor(.)) %>%
  ungroup() 
```

Data visualization

We first want to view all of the different cell phenotypes within the data, and then we can filter the data to see the ones that we're interested in, for example, CD45+ leukocytes.

```{r}
# to view all of the possible combinations
total_phenotypes <- all_gated %>%
  select(-filename, -percentage, -cell_no, -total_count_by_file) %>%
  group_by(HLA_DR, CD19, CD3, CD45, CD27) %>%
  unique() %>%
  ungroup() %>%
 select(CD45, CD3, CD19, HLA_DR, CD27)
 # mutate_all(~as.numeric.factor(.))

  
pheatmap(total_phenotypes, cluster_rows = FALSE, cluster_cols = FALSE, 
         color = viridis_colors, show_rownames = FALSE)

# gives the total number of populations
nrow(total_phenotypes) 

# view the specific cell phenotypes and percentages we're interested in
sample_populations <- all_gated %>%
  dplyr::filter(CD45 == 1) %>%
  select(-filename, -percentage, -cell_no, -total_count_by_file) %>%
  group_by(CD45, CD3, CD19, HLA_DR, CD27) %>%
  unique() %>%
  ungroup() %>%
  mutate(population = paste0("Pop", 1:length(CD45)))

```

Data visualization

- phenotype plot

Want to add annotations to the phenotype plot based on expression of different markers. The phenotype plot is then arranged and split by the lineage (I should try to find a way to do this automatically).

```{r}
# Split populations based on T or B cells
my_colors <- list(lineage = c(`T cell` = "darkorchid1", `B cell` = "#F8766D",
                `CD3+ B cells` = "#00B0F6", `Other Luekocyte` = "yellow"))


test_rearrange <- sample_populations %>%
  select(CD45, CD3, CD19, HLA_DR, CD27) %>%
  arrange(CD3, CD19) %>%
  mutate(population = paste0("Pop", c(1:nrow(sample_populations)))) %>%
  column_to_rownames("population") 
  #mutate_all(~as.numeric.factor(.)) %>%
  
annotation <- test_rearrange %>%
  mutate(lineage = ifelse(CD3 == 1 & CD19 == 0 , "T cell",
                          ifelse(CD3 == 0 & CD19 == 1, "B cell", 
                                 ifelse(CD3 == 1 & CD19 == 1, "CD3+ B cells", "Other Luekocyte")))) %>%
  select(lineage) %>%
  mutate(population = paste0("Pop", c(1:nrow(sample_populations)))) %>%
  mutate(lineage = as.factor(lineage)) %>%
  column_to_rownames("population")
  
pheatmap(test_rearrange, cluster_rows = FALSE, cluster_cols = FALSE,
           labels_row = rownames(annotation), 
           annotation_row = annotation,  annotation_colors = my_colors,  color = viridis_colors,
           cellwidth = 15, cellheight = 15, angle_col = 45,
           main = "Leukocytes")
```

Note I cannot do a correlation plot because I only have 1 sample (not multiple datapoints to see how similar populations are to each other)

```{r}
# convert the population rowname back to column so that we can use it for further analysis
test_rearrange <- test_rearrange %>%
  rownames_to_column("population")

# add back in the percentage data 
sample_populations_all_groups <- left_join(test_rearrange, all_gated) %>%
  select(population, percentage, -filename) %>%
  mutate_all(funs(replace_na(., 0)))
```

Data visualization

- times series

```{r}
ggplot(sample_populations_all_groups, aes(x = factor(population, 
                                                     levels = c(paste0("Pop", 1:nrow(sample_populations_all_groups)))), 
                                          y = percentage, fill = "pink")) +
  geom_bar(stat = "identity") +
  xlab("Populations") +
  ylab("Percent of Cells") +
  ggtitle("Cell Percentage of Total Live Leukocytes") +
  scale_color_manual(values = viridis_colors) +
  theme_gray() +
  theme(axis.text.x = element_text(angle = 45, size = 13, hjust = 1),
        axis.text.y = element_text(size = 13),
        strip.text.x = element_text(size = 10),
        axis.title = element_text(size = 20),
        title = element_text(size = 20),
        legend.position = "none")
```

Confirm pipeline populations with manual gating
```{r}

# read in and clean manual gating percentage data
manual_gating <- read_xlsx("../Data/flow/Human_Clinical/manual_gating.xlsx") %>%
  dplyr::rename(`population` = "..1",
                percent_manual = "Manual percent") %>%
  na.omit()

# prepare the flow CFU data for joining with manual gating
sample_populations_all_groups <- sample_populations_all_groups %>%
  dplyr::rename(percent_pipeline = percentage)


# should add absolute value of the percent_pipeline-percent_manual for error (abs)
# join the manual and pipeline percentage data
comparison <- full_join(manual_gating, sample_populations_all_groups, by = c("population")) %>%
  mutate(difference = round(percent_pipeline - percent_manual, digits = 2)) %>%
  mutate(error = round(100*(percent_pipeline - percent_manual)/percent_manual, digits = 2)) %>%
  mutate(percent_manual = round(percent_manual, digits = 2),
         percent_pipeline = round(percent_pipeline, digits = 2)) %>%
  mutate(absolute_difference = abs(difference),
         average_difference = mean(absolute_difference)) %>%
  select(population, percent_manual, percent_pipeline, absolute_difference, average_difference) 

# print out the comparison data in a pretty table
comparison[1:15,] %>%
  mutate(Population = population,
         `% Based On Manual Gating` = percent_manual,
         `% Based on Automated Pipeline` = percent_pipeline,
         `Absolute Difference` = absolute_difference,
         `Average Difference` = average_difference) %>%
  select(Population, `% Based On Manual Gating`, `% Based on Automated Pipeline`, `Absolute Difference`, `Average Difference`) %>%
  kable(align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  row_spec(0:nrow(comparison), color = "black") %>%
  print()

# compare the two gating types with manual v. pipeline plot
ggplot(comparison, aes(x = percent_pipeline, y = percent_manual)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  stat_cor(aes(x = percent_pipeline, y = percent_manual), data = comparison, "spearman") +
  ggtitle("Human Clinical Data: Manual vs. Pipeline Percentage") +
  xlab("Pipeline Percent") +
  ylab("Manual Percent") +
  theme_classic()
```


Try t-SNE

```{r}
all_gated_tSNE <- all_gated %>%
  select(filename, HLA_DR, CD19, CD3, CD45, CD27)

colors = rainbow(length(unique(all_gated_tSNE$filename)))
names(colors) = unique(all_gated_tSNE$filename)

tsne <- Rtsne(all_gated_tSNE[,-1], dims = 2, perplexity=1, verbose=TRUE, max_iter = 500)

## Plotting
data_plot <- as.data.frame(tsne$Y)
colnames(data_plot) <- c("tSNE_1", "tSNE_2")

ggplot(data_plot, aes(x = tSNE_1, y = tSNE_2, col = colors)) + 
  geom_point(size = 0.2) + 
  coord_fixed(ratio = 1) + 
  ggtitle("t-SNE projection with FlowSOM clustering") + 
  theme_bw()
```

Try to add color to t-SNE
```{r}
#https://support.bioconductor.org/p/60421/
library(premessa)
gated_data <- getData(gs, "leukocytes") %>% 
  as_flowframe() #https://rdrr.io/github/ParkerICI/premessa/man/as_flowFrame.html

gated_data[[1]]

exprs(gated_data) <- all_gated

#####

data_plot <- as.data.frame(tsne$Y)
colnames(data_plot) <- c("tSNE_1", "tSNE_2")

head(data_plot)
dim(data_plot)  ## should match length of labels_plot (otherwise labels will not match up correctly)

data_plot[, "cluster"] <- as.factor(labels_plot)

head(data_plot)


# plot 2-dimensional t-SNE projection

ggplot(data_plot, aes(x = tSNE_1, y = tSNE_2, , color = cluster)) + 
  geom_point(size = 0.2) + 
  coord_fixed(ratio = 1) + 
  ggtitle("t-SNE projection with FlowSOM clustering") + 
  theme_bw()

```

Try FlowSOM

```{r}
# Coerce ncdfFlowSet to flowSet
# flowSet contains 10 experiments (samples) with column names of the markers/parameters on the flow cytometer
# this is an S4 object
gated_data_flowSOM <- getData(gs, "live") %>% 
  as.flowSet()

# Adult FlowSOM
# FlowSOM class possibly in list form with $data seems to contain the markers as column labels and values of the markers, but there are negative values.. could $scaled.center contain the average of each of the markers to normalize values?
fSOM_all_gated <- ReadInput(gated_data, compensate = TRUE, 
                              transform = TRUE, scale = TRUE) 

# FlowSOM class added following
# - $map$codes : 100 rows = 100 nodes, average value?
# - $map$mapping : [ ,1] node where each cell is assigned, [ , 2] ??
# - $map$medianValues : 100 rows = 100 nodes, median value per node
# - $map$sdValue : 100 rows = 100 nodes, standard devation from ??
fSOM_all_gated  <-  BuildSOM(fSOM_all_gated , colsToUse = c(27:45))

# FlowSOM class added following
# - $MST$graph : edges to connect nodes, ex. node 1 -- node 4
# - $MST$l : 100 rows = 100 nodes, ???
# - $MST$size : 100 rows = 100 nodes, size of nodes for number of cells in each node??
fSOM_all_gated  <- BuildMST(fSOM_all_gated)

# integer class : vector containing the 20 metaclusters to add to appropriate nodes
metacl <- MetaClustering(fSOM_all_gated $map$codes, 
                                     "metaClustering_consensus", nClus = 20)

PlotStars(fSOM_all_gated , backgroundValues = as.factor(metacl), main = "All Gated Concat FlowSOM")
```

Plot CD3 v. CD19

```{r}


CD3_CD19_for_plot <- all_gated_df %>%
  mutate(filename= str_replace_all(filename, "\\s", "_")) %>%
  select(ends_with(".A"), -`FSC.A`, filename) %>%
  dplyr::rename(`HLA_DR` = "FITC.A",
         `CD19` = "PE.A",
        `CD3` =  "PE.Cy5.A",       
         `CD45` = "PE.Cy7.A",
         `CD27` = "APC.A")  %>%
  na.omit() %>%
  dplyr::filter(`SSC.A` != max(`SSC.A`))

ggplot(CD3_CD19_for_plot, aes(x = CD3, y = CD19)) +
   geom_hex(bins = 100) +
   scale_fill_viridis_c() +
  scale_x_log10() +
  scale_y_log10() +
   ylab("CD19") +
   geom_vline(xintercept = gate_mindensity_amy(CD3_sc, "CD3")) +
  geom_hline(yintercept = gate_mindensity_amy(CD19_sc, "CD19")) +
  theme_gray()+
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 20))
```
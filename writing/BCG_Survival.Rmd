---
title: "BCG_Survival"
output: html_document
---

This dataset includes two different mouse strains (C57BL/6 and NOS-2 KO) that were vaccinated with either PBS (control) or BCG. They were evaluated via CFUs for bacterial burden and flow cytometry for immune populations 30, 90, and 160 days post-vaccination. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First, the packages must be loaded.
```{r warning= FALSE}
library(openCyto)
library(flowClust)
library(data.table)
library(flowCore)
library(ggcyto)
library(FlowSOM)
library(dplyr)
library(pheatmap)
library(stringr)
library(tidyr)
library(readxl)
library(gridExtra)
library(ggcorrplot)
library(tidyverse)
library(scales)
library(viridis)
library(superheat)
library(kableExtra)
```

I have created a few functions to make it easier to analyze the data.

- clean_FMO_after_gate:renames the columns; it also removes SSC boundary effects
- statSmoothFunc: copied from <https://gist.github.com/kdauria/524eade46135f6348140> to add r^2 to correlation plots
- stat_smooth_func: copied from <https://gist.github.com/kdauria/524eade46135f6348140> to add r^2 to correlation plots
- phenotype_heatmap: to create the phenotype graphs with the populations and marker expression
- as.numeric.factor: convert the factors for the marker names into numeric for plotting
```{r}

clean_FMO_after_gate <- function(FMO_df) {
  FMO_df %>%
  select(ends_with(".A"), -`FSC.A`, `SSC.A`, filename) %>%
  dplyr::rename(`CXCR3` = "APC.A",
         `CD44` = "APC.Fire.750.A",
        `CD103` =  "APC.R700.A",       
         `CD3` = "Alexa.Fluor.532.A",
         `Sca1` = "BB515.A",
         `CCR7` = "BV421.A",
         `CD4` = "BV480.A",
         `CD69` = "BV510.A",
         `CD8` = "BV570.A", 
         `CTLA4` = "BV605.A",
         `CD27` = "BV650.A",
         `CD153` = "BV711.A",
         `KLRG1` = "BV785.A",
         `CXCR1` = "PE.A",
         `CD122` = "PE.Cy5.A",
         `PD1` = "PE.Cy7.A", 
         `CD62L` = "PE.Dazzle594.A",
         `CD45RB` = "Pacific.Blue.A", 
         `CD28` = "PerCP.Cy5.5.A",
         `CXCR5` = "PerCP.eFluor.710.A") %>%
   na.omit()%>%
  dplyr::filter(`SSC.A` != max(`SSC.A`))

}


# taken from https://gist.github.com/kdauria/524eade46135f6348140
stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

viridis_colors <- c("#3F4788FF", "#56C667FF")

phenotype_heatmap <- function(csv_file, population_no, title) {
  pheatmap(csv_file, cluster_rows = FALSE, cluster_cols = FALSE, 
           color = viridis_colors, cellwidth = 15, cellheight = 15,
           labels_row = paste("Pop", population_no), main = title)
}

as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}

```
